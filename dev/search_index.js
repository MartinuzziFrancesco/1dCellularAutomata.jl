var documenterSearchIndex = {"docs":
[{"location":"api/general/#General-APIs","page":"General APIs","title":"General APIs","text":"","category":"section"},{"location":"api/general/","page":"General APIs","title":"General APIs","text":"    CellularAutomaton","category":"page"},{"location":"api/general/#CellularAutomata.CellularAutomaton","page":"General APIs","title":"CellularAutomata.CellularAutomaton","text":"CellularAutomaton(rule::AbstractODRule, initial_conditions, generations)\nCellularAutomaton(rule::AbstractTDRule, initial_conditions, generations)\n\nGiven a cellular automata rule (inluded in the library or provided by the user) returns a CellularAutomaton evolution with given initial conditions and number of generations. OD indicates one-diomensional cellular automata rules, TD indicates two-dimensiona cellular automata rules.\n\n\n\n\n\n","category":"type"},{"location":"api/twodim/#Two-dimensional-Cellular-Automata","page":"Two Dimensial CA","title":"Two dimensional Cellular Automata","text":"","category":"section"},{"location":"api/twodim/#Life-Like-Cellular-Automata","page":"Two Dimensial CA","title":"Life-Like Cellular Automata","text":"","category":"section"},{"location":"api/twodim/","page":"Two Dimensial CA","title":"Two Dimensial CA","text":"    Life","category":"page"},{"location":"api/twodim/#CellularAutomata.Life","page":"Two Dimensial CA","title":"CellularAutomata.Life","text":"Life(life_description; radius=1)\n\nReturns a Life object given a tuple of tuples that follows the Golly notation ((b), (s)), where b stands for birth and s for survival. These values indicates the number of neighbouring cells needed to birth a new one in the following generation, or to make the current alive one survive.\n\n\n\n\n\n","category":"type"},{"location":"onedim/onedimensionca/#One-Dimensional-Cellular-Automata","page":"One dimensional CA","title":"One Dimensional Cellular Automata","text":"","category":"section"},{"location":"onedim/onedimensionca/#Elementary-Cellular-Automata","page":"One dimensional CA","title":"Elementary Cellular Automata","text":"","category":"section"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Elementary Cellular Automata (ECA) have a radius of one and can be in only two possible states. Here we show a couple of examples:","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Rule 18","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"using CellularAutomata, Plots\n\nstates = 2\nradius = 1\ngenerations = 50\nncells = 111\nstarting_val = zeros(Bool, ncells)\nstarting_val[Int(floor(ncells/2)+1)] = 1\n\nrule = 18\n\nca = CellularAutomaton(DCA(rule), starting_val, generations)\n\nheatmap(ca.evolution, \n    yflip=true, \n    c=cgrad([:white, :black]),\n    legend = :none,\n    axis=false,\n    ticks=false)","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"(Image: dca18)","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Rule 30","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"using CellularAutomata, Plots\n\nstates = 2\nradius = 1\ngenerations = 50\nncells = 111\nstarting_val = zeros(Bool, ncells)\nstarting_val[Int(floor(ncells/2)+1)] = 1\n\nrule = 30\n\nca = CellularAutomaton(DCA(rule), starting_val, generations)\n\nheatmap(ca.evolution, \n    yflip=true, \n    c=cgrad([:white, :black]),\n    legend = :none,\n    axis=false,\n    ticks=false)","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"(Image: dca30)","category":"page"},{"location":"onedim/onedimensionca/#Multiple-States-Cellular-Automata","page":"One dimensional CA","title":"Multiple States Cellular Automata","text":"","category":"section"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"General Cellular Automata have the same rule of ECA but they can have a radius larger than unity and/or a number of states greater than two. Here are provided examples for every possible permutation, starting with a Cellular Automaton with 3 states.","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Rule 7110222193934","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"using CellularAutomata, Plots\n\nstates = 3\nradius = 1\ngenerations = 50\nncells = 111\nstarting_val = zeros(ncells)\nstarting_val[Int(floor(ncells/2)+1)] = 2\n\nrule = 7110222193934 \n\nca = CellularAutomaton(DCA(rule,states=states,radius=radius), \n                       starting_val, generations)\n\nheatmap(ca.evolution, \n    yflip=true, \n    c=cgrad([:white, :black]),\n    legend = :none,\n    axis=false,\n    ticks=false,\n    size=(ncells*10, generations*10))","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"(Image: dca7110222193934)","category":"page"},{"location":"onedim/onedimensionca/#Larger-Radius-Cellular-Automata","page":"One dimensional CA","title":"Larger Radius Cellular Automata","text":"","category":"section"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"The following examples shows a Cellular Automaton with radius=2, with two only possible states:","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Rule 1388968789","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"using CellularAutomata, Plots\n\nstates = 2\nradius = 2\ngenerations = 30\nncells = 111\nstarting_val = zeros(ncells)\nstarting_val[Int(floor(ncells/2)+1)] = 1\n\nrule = 1388968789 \n\nca = CellularAutomaton(DCA(rule,states=states,radius=radius), \n                           starting_val, generations)\n\nheatmap(ca.evolution, \n    yflip=true, \n    c=cgrad([:white, :black]),\n    legend = :none,\n    axis=false,\n    ticks=false,\n    size=(ncells*10, generations*10))","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"(Image: dca1388968789)","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"And finally, three states with a radius equal to two:","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Rule 914752986721674989234787899872473589234512347899","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"using CellularAutomata, Plots\n\nstates = 3\nradius = 2\ngenerations = 30\nncells = 111\nstarting_val = zeros(ncells)\nstarting_val[Int(floor(ncells/2)+1)] = 2\n\nrule = 914752986721674989234787899872473589234512347899 \n\nca = CellularAutomaton(DCA(rule,states=states,radius=radius), \n                       starting_val, generations)\n\nheatmap(ca.evolution, \n    yflip=true, \n    c=cgrad([:white, :black]),\n    legend = :none,\n    axis=false,\n    ticks=false,\n    size=(ncells*10, generations*10))","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"(Image: dca914752986721674989234787899872473589234512347899)","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"It is also possible to specify asymmetric neighborhoods, giving a tuple to the kwarg detailing the number of neighbors to considerate at the left and right of the cell: Rule 1235","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"using CellularAutomata, Plots\n\nstates = 2\nradius = (2,1)\ngenerations = 30\nncells = 111\nstarting_val = zeros(ncells)\nstarting_val[Int(floor(ncells/2)+1)] = 1\n\nrule = 1235 \n\nca = CellularAutomaton(DCA(rule,states=states,radius=radius), \n                       starting_val, generations)\n\nheatmap(ca.evolution, \n    yflip=true, \n    c=cgrad([:white, :black]),\n    legend = :none,\n    axis=false,\n    ticks=false,\n    size=(ncells*10, generations*10))","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"(Image: dca1235)","category":"page"},{"location":"onedim/onedimensionca/#Totalistic-Cellular-Automata","page":"One dimensional CA","title":"Totalistic Cellular Automata","text":"","category":"section"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Totalistic Cellular Automata takes the sum of the neighborhood to calculate the value of the next step.","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Rule 1635","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"using CellularAutomata, Plots\n\nstates = 3\nradius = 1\ngenerations = 50\nncells = 111\nstarting_val = zeros(Integer, ncells)\nstarting_val[Int(floor(ncells/2)+1)] = 1\n\nrule = 1635\n\nca = CellularAutomaton(DCA(rule, states=states), \n                       starting_val, generations)\n\nheatmap(ca.evolution, \n    yflip=true, \n    c=cgrad([:white, :black]),\n    legend = :none,\n    axis=false,\n    ticks=false)","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"(Image: dca1635)","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Rule 107398","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"using CellularAutomata, Plots\n\nstates = 4\nradius = 1\ngenerations = 50\nncells = 111\nstarting_val = zeros(Integer, ncells)\nstarting_val[Int(floor(ncells/2)+1)] = 1\n\nrule = 107398\n\nca = CellularAutomaton(DCA(rule, states=states), \n                       starting_val, generations)\n\nheatmap(ca.evolution, \n    yflip=true, \n    c=cgrad([:white, :black]),\n    legend = :none,\n    axis=false,\n    ticks=false)","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"(Image: dca107398)","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Here are some results for a bigger radius, using a radius of 2 as an example.","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Rule 53","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"using CellularAutomata, Plots\n\nstates = 2\nradius = 2\ngenerations = 50\nncells = 111\nstarting_val = zeros(Integer, ncells)\nstarting_val[Int(floor(ncells/2)+1)] = 1\n\nrule = 53\n\nca = CellularAutomaton(DCA(rule, radius=radius), \n                           starting_val, generations)\n\nheatmap(ca.evolution, \n    yflip=true, \n    c=cgrad([:white, :black]),\n    legend = :none,\n    axis=false,\n    ticks=false)","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"(Image: dca53r2)","category":"page"},{"location":"onedim/onedimensionca/#Continuous-Cellular-Automata","page":"One dimensional CA","title":"Continuous Cellular Automata","text":"","category":"section"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Continuous Cellular Automata work in the same way as the totalistic but with real values. The examples are taken from the already mentioned book NKS.","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Rule 0.025","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"using CellularAutomata, Plots\n\ngenerations = 50\nncells = 111\nstarting_val = zeros(Float64, ncells)\nstarting_val[Int(floor(ncells/2)+1)] = 1.0\n\nrule = 0.025\n\nca = CellularAutomaton(CCA(rule), starting_val, generations)\n\nheatmap(ca.evolution, \n    yflip=true, \n    c=cgrad([:white, :black]),\n    legend = :none,\n    axis=false,\n    ticks=false)","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"(Image: cca0025)","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"Rule 0.2","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"using CellularAutomata, Plots\n\nradius = 1\ngenerations = 50\nncells = 111\nstarting_val = zeros(Float64, ncells)\nstarting_val[Int(floor(ncells/2)+1)] = 1.0\n\nrule = 0.2\n\nca = CellularAutomaton(CCA(rule, radius=radius), \n                       starting_val, generations)\n\nheatmap(ca.evolution, \n    yflip=true, \n    c=cgrad([:white, :black]),\n    legend = :none,\n    axis=false,\n    ticks=false)","category":"page"},{"location":"onedim/onedimensionca/","page":"One dimensional CA","title":"One dimensional CA","text":"(Image: cca02)","category":"page"},{"location":"twodim/twodimensionca/#Two-Dimensional-Cellular-Automata","page":"Two dimensional CA","title":"Two Dimensional Cellular Automata","text":"","category":"section"},{"location":"twodim/twodimensionca/#Game-of-Life","page":"Two dimensional CA","title":"Game of Life","text":"","category":"section"},{"location":"twodim/twodimensionca/","page":"Two dimensional CA","title":"Two dimensional CA","text":"This package can also reproduce Conway's Game of Life, and any variation based on it. The Life() function takes in a tuple containing the number of neighbors that will gave birth to a new cell, or that will make an existing cell survive. (For example in the Conways's Life the tuple (3, (2,3)) indicates having 3 live neighbors will give birth to an otherwise dead cell, and having either 2 or 3 lie neighbors will make an alive cell continue living.) The implementation follows the Golly notation.","category":"page"},{"location":"twodim/twodimensionca/","page":"Two dimensional CA","title":"Two dimensional CA","text":"This script reproduces the famous glider:","category":"page"},{"location":"twodim/twodimensionca/","page":"Two dimensional CA","title":"Two dimensional CA","text":"using CellularAutomata, Plots\n\nglider = [[0, 0, 1, 0, 0] [0, 0, 0, 1, 0] [0, 1, 1, 1, 0]]\n\nspace = zeros(Bool, 30, 30)\ninsert = 1\nspace[insert:insert+size(glider, 1)-1, insert:insert+size(glider, 2)-1] = glider\ngens = 100\nspace_gliding = CellularAutomaton(Life((3, (2,3))), space, gens)\n\nanim = @animate for i = 1:gens\n    heatmap(space_gliding.evolution[:,:,i], \n    yflip=true, \n    c=cgrad([:white, :black]),\n    legend = :none,\n    size=(1080,1080),\n    axis=false,\n    ticks=false)\nend\n \ngif(anim, \"glider.gif\", fps = 15)","category":"page"},{"location":"twodim/twodimensionca/","page":"Two dimensional CA","title":"Two dimensional CA","text":"(Image: glider)","category":"page"},{"location":"api/onedim/#One-dimensional-Cellular-Automata","page":"One Dimensional CA","title":"One dimensional Cellular Automata","text":"","category":"section"},{"location":"api/onedim/#Discrete-Cellular-Automata","page":"One Dimensional CA","title":"Discrete Cellular Automata","text":"","category":"section"},{"location":"api/onedim/","page":"One Dimensional CA","title":"One Dimensional CA","text":"    DCA","category":"page"},{"location":"api/onedim/#CellularAutomata.DCA","page":"One Dimensional CA","title":"CellularAutomata.DCA","text":"DCA(rule; states=2, radius=1)\n\nReturns a DCA object given a specific rule, number of states and radius. The ruleset for the rule is computed and stored in the struct as well.\n\n\n\n\n\n","category":"type"},{"location":"api/onedim/","page":"One Dimensional CA","title":"One Dimensional CA","text":"    TCA","category":"page"},{"location":"api/onedim/#CellularAutomata.TCA","page":"One Dimensional CA","title":"CellularAutomata.TCA","text":"TCA(code; states=2, radius=1)\n\nReturns a TCA object given a specific code, number of states and radius. The ruleset for the rule is computed and stored in the struct as well.\n\n\n\n\n\n","category":"type"},{"location":"api/onedim/#Continuous-Cellular-Automata","page":"One Dimensional CA","title":"Continuous Cellular Automata","text":"","category":"section"},{"location":"api/onedim/","page":"One Dimensional CA","title":"One Dimensional CA","text":"    CCA","category":"page"},{"location":"api/onedim/#CellularAutomata.CCA","page":"One Dimensional CA","title":"CellularAutomata.CCA","text":"TCA(code; radius=1)\n\nReturns a CCA object given a specific code and radius.\n\n\n\n\n\n","category":"type"},{"location":"#CellularAutomata.jl","page":"CellularAutomata.jl","title":"CellularAutomata.jl","text":"","category":"section"},{"location":"","page":"CellularAutomata.jl","title":"CellularAutomata.jl","text":"This package is meant to be a complete Open source reference for everything regarding Cellular Automata. In it you will find wayd to create one and two dimensional Cellular Automata models and functions  to analyze them","category":"page"},{"location":"#General-usage","page":"CellularAutomata.jl","title":"General usage","text":"","category":"section"},{"location":"","page":"CellularAutomata.jl","title":"CellularAutomata.jl","text":"The main function is given by CellularAutomaton where rule is a function returning the next state of the Cellular Automata. ","category":"page"},{"location":"#Contributions","page":"CellularAutomata.jl","title":"Contributions","text":"","category":"section"},{"location":"","page":"CellularAutomata.jl","title":"CellularAutomata.jl","text":"Contributions are more than welcomed! I do not have too much bandwidth for this package at the moment, but I will try to take care of any contributions should they come.","category":"page"}]
}
